name: Stage build and deploy

on:
  push:
    branches:
      - main
    workflow_dispatch:

env:
  REGISTRY: ghcr.io
  SPRING_PROFILES_ACTIVE: stage
  WWW_DOMAIN_NAME: www.stage.diyaccounting.co.uk
  #AWS_ACCESS_KEY_ID: ${AWS_ACCESS_KEY_ID}
  #AWS_SECRET_ACCESS_KEY: ${AWS_SECRET_ACCESS_KEY}
  #AWS_DEFAULT_REGION: eu-west-2

jobs:
  publish:
    runs-on: ubuntu-latest 
    permissions: 
      contents: read
      packages: write 
    steps:

      - uses: actions/checkout@v3

      - run: mkdir -p './mirror'

      - run: docker compose --file ./docker-compose-mount-content.yml build ;
      - run: docker compose --file ./docker-compose-mount-content.yml up --detach ;
      - run: until docker compose --file ./docker-compose-mount-content.yml ps | grep -v -e 'NAME' | wc -l | grep -e '^[[:space:]]*0[[:space:]]*$' ; do echo "Waiting for content..." ; sleep 1 ; done ;

      - run: docker compose build --no-cache --pull ;
      - run: docker compose up --force-recreate --detach ;
      #- run: until docker compose logs --tail="all" | grep -e 'Tomcat started on port(s): 8080 (http)' ; do echo "Waiting for the app..." ; sleep 1 ; done ;
      - run: until docker compose logs | grep -e "Tomcat started on port(s).*8080 (http)" ; do echo "Waiting for the app..." ; sleep 1 ; done ;

      - run: ./create-mirror-from-cluster.sh

      #- run: aws s3 sync './mirror' "s3://${WWW_DOMAIN_NAME?}/" --exclude '*content*' --delete --acl public-read ;
      #- run: aws s3 sync './mirror' "s3://${WWW_DOMAIN_NAME?}/" --exclude '*' --include '*content*'  --content-type 'application/javascript' --delete --acl public-read ;
      #- run: aws s3 ls --summarize --human-readable "s3://${WWW_DOMAIN_NAME?}"

      # TODO: terraform deployment

      # TODO: terraform destroy (in a separate workflow at the end of the day)
